<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>한문 텍스트 교감기 (Classical Chinese Text Collator)</title>
    <style>
        /* CJK Font Stack: system fonts only (offline) */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Noto Sans CJK KR', 'Noto Sans CJK TC', 'Noto Sans CJK SC', 'Noto Sans CJK JP',
                         '源ノ角ゴシック', 'Source Han Sans', 'Noto Sans KR', 'Malgun Gothic', '맑은 고딕',
                         'Microsoft YaHei', '微软雅黑', 'PingFang SC', 'PingFang TC', 'Hiragino Sans',
                         'MS Gothic', 'SimSun', 'MingLiU', sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 30px 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 1.8em;
            color: #2c3e50;
        }

        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 30px;
            font-size: 0.95em;
        }

        .upload-section {
            background: #fff;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            margin-bottom: 20px;
        }

        .upload-section h2 {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .file-input-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 20px;
        }

        .file-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .file-row label {
            min-width: 80px;
            font-weight: bold;
            color: #555;
        }

        .file-row input[type="file"] {
            flex: 1;
            padding: 8px;
            border: 2px dashed #ccc;
            border-radius: 8px;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        .file-row input[type="file"]:hover {
            border-color: #3498db;
        }

        .file-status {
            font-size: 0.85em;
            color: #27ae60;
            min-width: 100px;
            text-align: right;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .btn-add {
            background: #ecf0f1;
            color: #2c3e50;
        }

        .btn-add:hover {
            background: #bdc3c7;
        }

        .btn-compare {
            background: #3498db;
            color: #fff;
        }

        .btn-compare:hover {
            background: #2980b9;
        }

        .btn-compare:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        .btn-remove {
            background: #e74c3c;
            color: #fff;
            padding: 6px 12px;
            font-size: 0.85em;
        }

        .btn-remove:hover {
            background: #c0392b;
        }

        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: #fff;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }

        .modal h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .modal p {
            margin-bottom: 15px;
            color: #555;
        }

        .pair-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .pair-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
        }

        .pair-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .pair-item label {
            cursor: pointer;
            font-size: 0.95em;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .btn-cancel {
            background: #ecf0f1;
            color: #2c3e50;
        }

        .btn-cancel:hover {
            background: #bdc3c7;
        }

        .btn-confirm {
            background: #27ae60;
            color: #fff;
        }

        .btn-confirm:hover {
            background: #219a52;
        }

        /* Loading */
        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid #ecf0f1;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .info-box {
            background: #eaf6ff;
            border-left: 4px solid #3498db;
            padding: 15px;
            border-radius: 0 8px 8px 0;
            margin-top: 20px;
            font-size: 0.9em;
            color: #2c3e50;
        }

        .encoding-select {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid #ccc;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>漢文 텍스트 교감기</h1>
        <p class="subtitle">Classical Chinese Text Collator — 한문 텍스트 파일을 비교·교감합니다</p>

        <div class="upload-section">
            <h2>텍스트 파일 업로드</h2>
            <p style="color:#888; font-size:0.9em; margin-bottom:15px;">
                비교할 텍스트 파일(.txt)을 2개 이상 업로드하세요. 한국·대만·일본·중국식 한자를 모두 지원합니다.
            </p>

            <div id="fileInputs" class="file-input-group">
                <div class="file-row" data-index="0">
                    <label>파일 A:</label>
                    <input type="file" accept=".txt,.text" onchange="handleFile(this, 0)">
                    <select class="encoding-select" data-index="0">
                        <option value="UTF-8" selected>UTF-8</option>
                        <option value="EUC-KR">EUC-KR</option>
                        <option value="Big5">Big5 (繁體)</option>
                        <option value="Shift_JIS">Shift_JIS</option>
                        <option value="GB2312">GB2312 (简体)</option>
                        <option value="GB18030">GB18030</option>
                    </select>
                    <span class="file-status" id="status-0"></span>
                </div>
                <div class="file-row" data-index="1">
                    <label>파일 B:</label>
                    <input type="file" accept=".txt,.text" onchange="handleFile(this, 1)">
                    <select class="encoding-select" data-index="1">
                        <option value="UTF-8" selected>UTF-8</option>
                        <option value="EUC-KR">EUC-KR</option>
                        <option value="Big5">Big5 (繁體)</option>
                        <option value="Shift_JIS">Shift_JIS</option>
                        <option value="GB2312">GB2312 (简体)</option>
                        <option value="GB18030">GB18030</option>
                    </select>
                    <span class="file-status" id="status-1"></span>
                </div>
            </div>

            <div class="btn-group">
                <button class="btn-add" onclick="addFileInput()">+ 파일 추가</button>
                <button class="btn-compare" id="btnCompare" onclick="openSelectionModal()" disabled>교감 시작</button>
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>텍스트를 비교하고 있습니다... 잠시만 기다려 주세요.</p>
        </div>

        <div class="info-box">
            <strong>사용 안내:</strong><br>
            1. 비교할 텍스트 파일을 2개 이상 업로드합니다.<br>
            2. 파일 인코딩이 UTF-8이 아닌 경우 해당 인코딩을 선택합니다.<br>
            3. 「교감 시작」을 누르면 비교할 파일 조합을 선택하는 창이 나타납니다.<br>
            4. 원하는 조합을 선택하면 새 창에서 결과를 확인할 수 있습니다.<br>
            5. 결과 페이지에서 HTML 파일로 저장할 수 있습니다.
        </div>
    </div>

    <!-- Selection Modal -->
    <div class="modal-overlay" id="selectionModal">
        <div class="modal">
            <h3>비교할 파일 조합 선택</h3>
            <p>교감할 파일 쌍을 선택하세요. 각 조합에 대해 별도의 결과 창이 열립니다.</p>
            <div class="pair-list" id="pairList"></div>
            <div class="modal-buttons">
                <button class="btn-cancel" onclick="closeModal()">취소</button>
                <button class="btn-confirm" onclick="startComparison()">교감 실행</button>
            </div>
        </div>
    </div>

    <script>
    // ===== State =====
    const files = {};      // index -> { name, content }
    let fileCount = 2;
    const fileLabels = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

    // ===== File Handling =====
    function handleFile(input, index) {
        const file = input.files[0];
        if (!file) return;

        const encodingSelect = document.querySelector(`.encoding-select[data-index="${index}"]`);
        const encoding = encodingSelect ? encodingSelect.value : 'UTF-8';

        const reader = new FileReader();
        reader.onload = function(e) {
            let text = e.target.result;
            // Normalize Unicode (NFC) to unify CJK variants where possible
            if (text.normalize) {
                text = text.normalize('NFC');
            }
            // Remove BOM if present
            if (text.charCodeAt(0) === 0xFEFF) {
                text = text.substring(1);
            }
            files[index] = { name: file.name, content: text };
            document.getElementById(`status-${index}`).textContent = `✓ ${file.name} (${text.length}자)`;
            updateCompareButton();
        };
        reader.onerror = function() {
            alert(`파일 읽기 오류: ${file.name}`);
        };
        reader.readAsText(file, encoding);
    }

    function addFileInput() {
        const idx = fileCount;
        fileCount++;
        const label = fileLabels[idx] || `F${idx}`;

        const row = document.createElement('div');
        row.className = 'file-row';
        row.dataset.index = idx;
        row.innerHTML = `
            <label>파일 ${label}:</label>
            <input type="file" accept=".txt,.text" onchange="handleFile(this, ${idx})">
            <select class="encoding-select" data-index="${idx}">
                <option value="UTF-8" selected>UTF-8</option>
                <option value="EUC-KR">EUC-KR</option>
                <option value="Big5">Big5 (繁體)</option>
                <option value="Shift_JIS">Shift_JIS</option>
                <option value="GB2312">GB2312 (简体)</option>
                <option value="GB18030">GB18030</option>
            </select>
            <span class="file-status" id="status-${idx}"></span>
            <button class="btn-remove" onclick="removeFileInput(${idx})">삭제</button>
        `;
        document.getElementById('fileInputs').appendChild(row);
    }

    function removeFileInput(idx) {
        const row = document.querySelector(`.file-row[data-index="${idx}"]`);
        if (row) row.remove();
        delete files[idx];
        updateCompareButton();
    }

    function updateCompareButton() {
        const loadedCount = Object.keys(files).length;
        document.getElementById('btnCompare').disabled = loadedCount < 2;
    }

    // ===== Modal =====
    function openSelectionModal() {
        const indices = Object.keys(files).map(Number).sort((a, b) => a - b);
        if (indices.length < 2) {
            alert('파일을 2개 이상 업로드하세요.');
            return;
        }

        const pairList = document.getElementById('pairList');
        pairList.innerHTML = '';

        // Generate all pairs
        for (let i = 0; i < indices.length; i++) {
            for (let j = i + 1; j < indices.length; j++) {
                const a = indices[i], b = indices[j];
                const labelA = fileLabels[a] || `F${a}`;
                const labelB = fileLabels[b] || `F${b}`;
                const item = document.createElement('div');
                item.className = 'pair-item';
                item.innerHTML = `
                    <input type="checkbox" id="pair-${a}-${b}" value="${a},${b}" checked>
                    <label for="pair-${a}-${b}">
                        파일 ${labelA} (${files[a].name}) ↔ 파일 ${labelB} (${files[b].name})
                    </label>
                `;
                pairList.appendChild(item);
            }
        }

        document.getElementById('selectionModal').classList.add('active');
    }

    function closeModal() {
        document.getElementById('selectionModal').classList.remove('active');
    }

    function startComparison() {
        const checkboxes = document.querySelectorAll('#pairList input[type="checkbox"]:checked');
        if (checkboxes.length === 0) {
            alert('최소 1개의 비교 조합을 선택하세요.');
            return;
        }

        closeModal();
        document.getElementById('loading').classList.add('active');

        const pairs = Array.from(checkboxes).map(cb => cb.value.split(',').map(Number));

        // Process all pairs, then open ONE window with all results
        setTimeout(() => {
            const allResults = pairs.map(([a, b]) => ({
                result: compareTexts(files[a], files[b], a, b),
                idxA: a,
                idxB: b
            }));
            document.getElementById('loading').classList.remove('active');
            openResultWindow(allResults);
        }, 100);
    }

    // ===== LCS-based Diff Algorithm =====
    // Uses a character-level LCS to align two texts, handling 1:N and N:1 differences.
    function computeLCS(textA, textB) {
        const m = textA.length;
        const n = textB.length;

        // For very long texts, use the optimized approach
        // We use a space-optimized LCS that only stores two rows at a time,
        // then backtrack using the Hirschberg algorithm concept.
        // For texts under 10000 chars, use standard DP.
        if (m <= 10000 && n <= 10000) {
            return computeLCSStandard(textA, textB);
        } else {
            return computeLCSHirschberg(textA, textB);
        }
    }

    function computeLCSStandard(textA, textB) {
        const m = textA.length;
        const n = textB.length;

        // Build DP table
        const dp = new Array(m + 1);
        for (let i = 0; i <= m; i++) {
            dp[i] = new Uint32Array(n + 1);
        }

        for (let i = 1; i <= m; i++) {
            for (let j = 1; j <= n; j++) {
                if (textA[i - 1] === textB[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        // Backtrack to get alignment
        const alignment = [];
        let i = m, j = n;
        while (i > 0 && j > 0) {
            if (textA[i - 1] === textB[j - 1]) {
                alignment.unshift({ type: 'match', charA: textA[i - 1], charB: textB[j - 1], idxA: i - 1, idxB: j - 1 });
                i--; j--;
            } else if (dp[i - 1][j] >= dp[i][j - 1]) {
                alignment.unshift({ type: 'deleteA', charA: textA[i - 1], idxA: i - 1 });
                i--;
            } else {
                alignment.unshift({ type: 'insertB', charB: textB[j - 1], idxB: j - 1 });
                j--;
            }
        }
        while (i > 0) {
            alignment.unshift({ type: 'deleteA', charA: textA[i - 1], idxA: i - 1 });
            i--;
        }
        while (j > 0) {
            alignment.unshift({ type: 'insertB', charB: textB[j - 1], idxB: j - 1 });
            j--;
        }

        return alignment;
    }

    // Hirschberg's algorithm for space-efficient LCS on long texts
    function computeLCSHirschberg(textA, textB) {
        const m = textA.length;
        const n = textB.length;

        if (m === 0) {
            return Array.from(textB).map((ch, idx) => ({ type: 'insertB', charB: ch, idxB: idx }));
        }
        if (n === 0) {
            return Array.from(textA).map((ch, idx) => ({ type: 'deleteA', charA: ch, idxA: idx }));
        }
        if (m === 1) {
            const pos = textB.indexOf(textA[0]);
            const result = [];
            if (pos === -1) {
                // Character not found in textB at all
                result.push({ type: 'deleteA', charA: textA[0], idxA: 0 });
                for (let j = 0; j < n; j++) {
                    result.push({ type: 'insertB', charB: textB[j], idxB: j });
                }
            } else {
                for (let j = 0; j < n; j++) {
                    if (j === pos) {
                        result.push({ type: 'match', charA: textA[0], charB: textB[j], idxA: 0, idxB: j });
                    } else {
                        result.push({ type: 'insertB', charB: textB[j], idxB: j });
                    }
                }
            }
            return result;
        }
        if (n === 1) {
            const pos = textA.indexOf(textB[0]);
            const result = [];
            if (pos === -1) {
                for (let i = 0; i < m; i++) {
                    result.push({ type: 'deleteA', charA: textA[i], idxA: i });
                }
                result.push({ type: 'insertB', charB: textB[0], idxB: 0 });
            } else {
                for (let i = 0; i < m; i++) {
                    if (i === pos) {
                        result.push({ type: 'match', charA: textA[i], charB: textB[0], idxA: i, idxB: 0 });
                    } else {
                        result.push({ type: 'deleteA', charA: textA[i], idxA: i });
                    }
                }
            }
            return result;
        }

        const mid = Math.floor(m / 2);

        // Forward pass: LCS lengths for textA[0..mid] vs textB
        const scoreL = lcsLengthRow(textA.substring(0, mid), textB);

        // Backward pass: LCS lengths for reverse(textA[mid..m]) vs reverse(textB)
        const revA = reverseStr(textA.substring(mid));
        const revB = reverseStr(textB);
        const scoreR = lcsLengthRow(revA, revB);

        // Find optimal split point in textB
        let maxVal = -1, splitJ = 0;
        for (let j = 0; j <= n; j++) {
            const val = scoreL[j] + scoreR[n - j];
            if (val > maxVal) {
                maxVal = val;
                splitJ = j;
            }
        }

        // Recurse on both halves
        const leftAlign = computeLCSHirschberg(
            textA.substring(0, mid),
            textB.substring(0, splitJ)
        );
        const rightAlign = computeLCSHirschberg(
            textA.substring(mid),
            textB.substring(splitJ)
        );

        // Adjust indices in right half
        rightAlign.forEach(op => {
            if (op.idxA !== undefined) op.idxA += mid;
            if (op.idxB !== undefined) op.idxB += splitJ;
        });

        return leftAlign.concat(rightAlign);
    }

    function lcsLengthRow(a, b) {
        const m = a.length, n = b.length;
        let prev = new Uint32Array(n + 1);
        let curr = new Uint32Array(n + 1);

        for (let i = 1; i <= m; i++) {
            for (let j = 1; j <= n; j++) {
                if (a[i - 1] === b[j - 1]) {
                    curr[j] = prev[j - 1] + 1;
                } else {
                    curr[j] = Math.max(prev[j], curr[j - 1]);
                }
            }
            [prev, curr] = [curr, prev];
            curr.fill(0);
        }
        return prev;
    }

    function reverseStr(s) {
        return Array.from(s).reverse().join('');
    }

    // ===== Build Diff Segments =====
    function buildDiffSegments(alignment) {
        // Group alignment into segments: consecutive matches or consecutive diffs
        const segments = [];
        let currentDiff = null;

        for (const op of alignment) {
            if (op.type === 'match') {
                if (currentDiff) {
                    segments.push(currentDiff);
                    currentDiff = null;
                }
                segments.push({ type: 'match', char: op.charA });
            } else {
                if (!currentDiff) {
                    currentDiff = { type: 'diff', charsA: '', charsB: '' };
                }
                if (op.type === 'deleteA') {
                    currentDiff.charsA += op.charA;
                } else if (op.type === 'insertB') {
                    currentDiff.charsB += op.charB;
                }
            }
        }
        if (currentDiff) {
            segments.push(currentDiff);
        }

        return segments;
    }

    // ===== Preprocess: strip whitespace/newlines for pure character comparison =====
    function stripWhitespace(text) {
        return text.replace(/[\s\r\n\t\u3000]/g, '');
    }

    // ===== CJK Character Detection =====
    // Returns true if the character is a CJK ideograph (한자)
    function isCJK(ch) {
        const code = ch.codePointAt(0);
        return (
            (code >= 0x4E00 && code <= 0x9FFF) ||   // CJK Unified Ideographs
            (code >= 0x3400 && code <= 0x4DBF) ||   // CJK Unified Ideographs Extension A
            (code >= 0x20000 && code <= 0x2A6DF) || // Extension B
            (code >= 0x2A700 && code <= 0x2B73F) || // Extension C
            (code >= 0x2B740 && code <= 0x2B81F) || // Extension D
            (code >= 0x2B820 && code <= 0x2CEAF) || // Extension E
            (code >= 0x2CEB0 && code <= 0x2EBEF) || // Extension F
            (code >= 0x30000 && code <= 0x3134F) || // Extension G
            (code >= 0xF900 && code <= 0xFAFF) ||   // CJK Compatibility Ideographs
            (code >= 0x2F800 && code <= 0x2FA1F)    // CJK Compatibility Ideographs Supplement
        );
    }

    // Separates text into CJK-only string and a position map for non-CJK characters
    // Returns { cjkOnly: string, nonCjkMap: Map<cjkIndex, [{char, before:bool}]> }
    // nonCjkMap[i] = array of non-CJK chars that appear BEFORE the i-th CJK character
    // nonCjkMap[-1] = non-CJK chars that appear AFTER the last CJK character
    function separateCJK(text) {
        const cjkChars = [];
        const nonCjkMap = new Map();
        let pendingNonCjk = [];

        for (const ch of text) {
            if (isCJK(ch)) {
                const idx = cjkChars.length;
                if (pendingNonCjk.length > 0) {
                    nonCjkMap.set(idx, pendingNonCjk);
                    pendingNonCjk = [];
                }
                cjkChars.push(ch);
            } else {
                pendingNonCjk.push(ch);
            }
        }
        // Trailing non-CJK chars (after the last CJK character)
        if (pendingNonCjk.length > 0) {
            nonCjkMap.set(-1, pendingNonCjk);
        }

        return { cjkOnly: cjkChars.join(''), nonCjkMap };
    }

    // ===== Compare Two Texts =====
    function compareTexts(fileA, fileB, idxA, idxB) {
        const cleanA = stripWhitespace(fileA.content);
        const cleanB = stripWhitespace(fileB.content);

        // Separate CJK from non-CJK
        const parsedA = separateCJK(cleanA);
        const parsedB = separateCJK(cleanB);

        // Compare CJK characters only
        const alignment = computeLCS(parsedA.cjkOnly, parsedB.cjkOnly);
        const segments = buildDiffSegments(alignment);

        // Count statistics (CJK only)
        let matchCount = 0;
        let diffCharsA = 0;
        let diffCharsB = 0;

        segments.forEach(seg => {
            if (seg.type === 'match') {
                matchCount++;
            } else {
                diffCharsA += seg.charsA.length;
                diffCharsB += seg.charsB.length;
            }
        });

        return {
            fileA: fileA,
            fileB: fileB,
            segments: segments,
            parsedA: parsedA,
            parsedB: parsedB,
            stats: {
                totalA: parsedA.cjkOnly.length,
                totalB: parsedB.cjkOnly.length,
                matchCount: matchCount,
                diffCharsA: diffCharsA,
                diffCharsB: diffCharsB,
            }
        };
    }

    // ===== Helper: render non-CJK chars as neutral (gray) spans =====
    function renderNonCjk(chars) {
        if (!chars || chars.length === 0) return '';
        return `<span class="non-cjk">${escapeHtml(chars.join(''))}</span>`;
    }

    // ===== Build HTML for one comparison pair =====
    function buildPairHtml(result, idxA, idxB) {
        const { fileA, fileB, segments, parsedA, parsedB, stats } = result;
        const labelA = fileLabels[idxA] || `F${idxA}`;
        const labelB = fileLabels[idxB] || `F${idxB}`;

        const totalDiffA = stats.diffCharsA;
        const totalDiffB = stats.diffCharsB;
        const diffPctA = stats.totalA > 0 ? (totalDiffA / stats.totalA * 100).toFixed(2) : '0.00';
        const diffPctB = stats.totalB > 0 ? (totalDiffB / stats.totalB * 100).toFixed(2) : '0.00';

        let htmlA = '';
        let htmlB = '';
        let htmlCombined = '';
        let cjkIdxA = 0;
        let cjkIdxB = 0;

        segments.forEach(seg => {
            if (seg.type === 'match') {
                const nonCjkA = parsedA.nonCjkMap.get(cjkIdxA);
                const nonCjkB = parsedB.nonCjkMap.get(cjkIdxB);
                if (nonCjkA) htmlA += renderNonCjk(nonCjkA);
                if (nonCjkB) htmlB += renderNonCjk(nonCjkB);
                if (nonCjkA) htmlCombined += renderNonCjk(nonCjkA);

                const escaped = escapeHtml(seg.char);
                htmlA += `<span class="match">${escaped}</span>`;
                htmlB += `<span class="match">${escaped}</span>`;
                htmlCombined += `<span class="match">${escaped}</span>`;
                cjkIdxA++;
                cjkIdxB++;
            } else {
                const lenA = seg.charsA.length;
                const lenB = seg.charsB.length;

                let nonCjkBeforeA = '';
                for (let k = 0; k < lenA; k++) {
                    const nc = parsedA.nonCjkMap.get(cjkIdxA + k);
                    if (nc) nonCjkBeforeA += renderNonCjk(nc);
                }
                let nonCjkBeforeB = '';
                for (let k = 0; k < lenB; k++) {
                    const nc = parsedB.nonCjkMap.get(cjkIdxB + k);
                    if (nc) nonCjkBeforeB += renderNonCjk(nc);
                }

                if (lenA > 0) {
                    htmlA += nonCjkBeforeA + `<span class="diff" title="파일 ${labelB}: ${escapeHtml(seg.charsB) || '(없음)'}">${escapeHtml(seg.charsA)}</span>`;
                    htmlCombined += nonCjkBeforeA + `<span class="diff diff-a" title="파일 ${labelA} 고유">${escapeHtml(seg.charsA)}</span>`;
                }
                if (lenB > 0) {
                    htmlB += nonCjkBeforeB + `<span class="diff" title="파일 ${labelA}: ${escapeHtml(seg.charsA) || '(없음)'}">${escapeHtml(seg.charsB)}</span>`;
                    htmlCombined += nonCjkBeforeB + `<span class="diff diff-b" title="파일 ${labelB} 고유">${escapeHtml(seg.charsB)}</span>`;
                }

                cjkIdxA += lenA;
                cjkIdxB += lenB;
            }
        });

        const trailA = parsedA.nonCjkMap.get(-1);
        const trailB = parsedB.nonCjkMap.get(-1);
        if (trailA) { htmlA += renderNonCjk(trailA); htmlCombined += renderNonCjk(trailA); }
        if (trailB) { htmlB += renderNonCjk(trailB); }

        return { labelA, labelB, fileA, fileB, stats, totalDiffA, totalDiffB, diffPctA, diffPctB, htmlA, htmlB, htmlCombined };
    }

    // ===== Open ONE Result Window with ALL pairs =====
    function openResultWindow(allResults) {
        // Build each pair's section
        const pairSections = allResults.map(({ result, idxA, idxB }, pairIdx) => {
            const p = buildPairHtml(result, idxA, idxB);
            const pairId = `pair${pairIdx}`;

            return `
    <!-- ===== Pair ${pairIdx}: ${escapeHtml(p.labelA)} ↔ ${escapeHtml(p.labelB)} ===== -->
    <div class="pair-section" id="${pairId}">
        <div class="header">
            <h1>파일 ${escapeHtml(p.labelA)} (${escapeHtml(p.fileA.name)}) ↔ 파일 ${escapeHtml(p.labelB)} (${escapeHtml(p.fileB.name)})</h1>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">파일 ${escapeHtml(p.labelA)} 한자 수</div>
                    <div class="stat-value">${p.stats.totalA.toLocaleString()}자</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">파일 ${escapeHtml(p.labelB)} 한자 수</div>
                    <div class="stat-value">${p.stats.totalB.toLocaleString()}자</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">동일한 한자 (검정)</div>
                    <div class="stat-value">${p.stats.matchCount.toLocaleString()}자</div>
                </div>
                <div class="stat-card diff-stat">
                    <div class="stat-label">파일 ${escapeHtml(p.labelA)} 상이한 한자 (빨강)</div>
                    <div class="stat-value">${p.totalDiffA.toLocaleString()}자</div>
                </div>
                <div class="stat-card diff-stat">
                    <div class="stat-label">파일 ${escapeHtml(p.labelB)} 상이한 한자 (빨강)</div>
                    <div class="stat-value">${p.totalDiffB.toLocaleString()}자</div>
                </div>
                <div class="stat-card pct-stat">
                    <div class="stat-label">파일 ${escapeHtml(p.labelA)} 차이 비율</div>
                    <div class="stat-value">${p.diffPctA}%</div>
                </div>
                <div class="stat-card pct-stat">
                    <div class="stat-label">파일 ${escapeHtml(p.labelB)} 차이 비율</div>
                    <div class="stat-value">${p.diffPctB}%</div>
                </div>
            </div>
            <div class="legend">
                <div class="legend-item"><span class="legend-color" style="background:#000"></span> 동일한 한자</div>
                <div class="legend-item"><span class="legend-color" style="background:#e74c3c"></span> 상이한 한자</div>
                <div class="legend-item"><span class="legend-color" style="background:#ffeaea"></span> 파일 ${escapeHtml(p.labelA)} 고유</div>
                <div class="legend-item"><span class="legend-color" style="background:#fff3cd"></span> 파일 ${escapeHtml(p.labelB)} 고유</div>
                <div class="legend-item"><span class="legend-color" style="background:#999"></span> 문장부호·숫자·영어 (통계 제외)</div>
            </div>
        </div>

        <div class="view-toolbar">
            <button class="view-btn active" onclick="switchView('${pairId}', 'combined', this)">통합 보기</button>
            <button class="view-btn" onclick="switchView('${pairId}', 'fileA', this)">파일 ${escapeHtml(p.labelA)} 보기</button>
            <button class="view-btn" onclick="switchView('${pairId}', 'fileB', this)">파일 ${escapeHtml(p.labelB)} 보기</button>
            <button class="view-btn" onclick="switchView('${pairId}', 'sideBySide', this)">나란히 보기</button>
        </div>

        <div class="text-panel active" data-pair="${pairId}" data-view="combined">
            <h2>통합 보기 — 두 파일의 차이를 한 눈에 비교</h2>
            <div class="text-content">${p.htmlCombined}</div>
        </div>
        <div class="text-panel" data-pair="${pairId}" data-view="fileA">
            <h2>파일 ${escapeHtml(p.labelA)} (${escapeHtml(p.fileA.name)}) — 빨간 글자에 마우스를 올리면 대응 글자 확인</h2>
            <div class="text-content">${p.htmlA}</div>
        </div>
        <div class="text-panel" data-pair="${pairId}" data-view="fileB">
            <h2>파일 ${escapeHtml(p.labelB)} (${escapeHtml(p.fileB.name)}) — 빨간 글자에 마우스를 올리면 대응 글자 확인</h2>
            <div class="text-content">${p.htmlB}</div>
        </div>
        <div class="text-panel" data-pair="${pairId}" data-view="sideBySide">
            <h2>나란히 보기</h2>
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px;">
                <div>
                    <h3 style="color:#7f8c8d; font-size:0.9em; margin-bottom:10px;">파일 ${escapeHtml(p.labelA)} (${escapeHtml(p.fileA.name)})</h3>
                    <div class="text-content" style="border-right:2px solid #eee; padding-right:15px;">${p.htmlA}</div>
                </div>
                <div>
                    <h3 style="color:#7f8c8d; font-size:0.9em; margin-bottom:10px;">파일 ${escapeHtml(p.labelB)} (${escapeHtml(p.fileB.name)})</h3>
                    <div class="text-content">${p.htmlB}</div>
                </div>
            </div>
        </div>
    </div>`;
        });

        // Build pair navigation tabs
        const pairTabs = allResults.map(({ result, idxA, idxB }, pairIdx) => {
            const lA = fileLabels[idxA] || `F${idxA}`;
            const lB = fileLabels[idxB] || `F${idxB}`;
            const active = pairIdx === 0 ? ' active' : '';
            return `<button class="pair-tab${active}" onclick="switchPair(${pairIdx}, this)">${escapeHtml(lA)} ↔ ${escapeHtml(lB)}</button>`;
        }).join('\n            ');

        const resultHtml = `<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>교감 결과</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Noto Sans CJK KR', 'Noto Sans CJK TC', 'Noto Sans CJK SC', 'Noto Sans CJK JP',
                         'Source Han Sans', 'Malgun Gothic', 'Microsoft YaHei', 'PingFang SC',
                         'Hiragino Sans', 'SimSun', 'MingLiU', sans-serif;
            background: #fafafa; color: #333; padding: 20px; line-height: 1.8;
        }
        /* Top navigation: pair tabs */
        .top-bar {
            background: #2c3e50; border-radius: 12px; padding: 15px 20px;
            margin-bottom: 20px; display: flex; gap: 10px; flex-wrap: wrap;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.15);
        }
        .top-bar-title {
            color: #fff; font-weight: bold; font-size: 1.1em; margin-right: 15px;
        }
        .pair-tab {
            padding: 8px 18px; border: none; border-radius: 6px;
            cursor: pointer; font-size: 0.9em; font-weight: bold;
            background: rgba(255,255,255,0.15); color: #ecf0f1;
            transition: all 0.2s;
        }
        .pair-tab:hover { background: rgba(255,255,255,0.3); }
        .pair-tab.active { background: #3498db; color: #fff; }
        .btn-save-all {
            margin-left: auto; padding: 8px 18px; border: none; border-radius: 6px;
            cursor: pointer; font-size: 0.9em; font-weight: bold;
            background: #27ae60; color: #fff; transition: all 0.2s;
        }
        .btn-save-all:hover { background: #219a52; }
        /* Pair sections */
        .pair-section { display: none; }
        .pair-section.active { display: block; }
        .header {
            background: #fff; border-radius: 12px; padding: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08); margin-bottom: 20px;
        }
        .header h1 { font-size: 1.5em; color: #2c3e50; margin-bottom: 15px; }
        .stats-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px; margin-bottom: 15px;
        }
        .stat-card {
            background: #f8f9fa; border-radius: 8px; padding: 12px 16px;
            border-left: 4px solid #3498db;
        }
        .stat-card.diff-stat { border-left-color: #e74c3c; }
        .stat-card.pct-stat { border-left-color: #f39c12; }
        .stat-label { font-size: 0.8em; color: #7f8c8d; }
        .stat-value { font-size: 1.4em; font-weight: bold; color: #2c3e50; }
        .view-toolbar {
            display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 20px;
        }
        .view-btn {
            padding: 8px 18px; border: none; border-radius: 6px;
            cursor: pointer; font-size: 0.9em; font-weight: bold;
            background: #ecf0f1; color: #2c3e50; transition: all 0.2s;
        }
        .view-btn:hover { background: #d5dbdb; }
        .view-btn.active { background: #3498db; color: #fff; }
        .text-panel {
            background: #fff; border-radius: 12px; padding: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            font-size: 1.2em; line-height: 2; display: none;
        }
        .text-panel.active { display: block; }
        .text-panel h2 {
            font-size: 1em; color: #7f8c8d; margin-bottom: 15px;
            padding-bottom: 10px; border-bottom: 1px solid #eee;
        }
        .match { color: #000; }
        .diff { color: #e74c3c; font-weight: bold; cursor: help; }
        .diff-a { background: #ffeaea; border-radius: 2px; padding: 0 1px; }
        .diff-b { background: #fff3cd; border-radius: 2px; padding: 0 1px; }
        .non-cjk { color: #999; font-weight: normal; }
        .legend { display: flex; gap: 20px; margin-top: 10px; font-size: 0.85em; color: #555; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 16px; height: 16px; border-radius: 3px; display: inline-block; }
    </style>
</head>
<body>
    <div class="top-bar">
        <span class="top-bar-title">漢文 교감 결과</span>
        ${pairTabs}
        <button class="btn-save-all" onclick="saveHtml()">HTML 저장</button>
    </div>

    ${pairSections.join('\n')}

    <script>
    // Show first pair by default
    document.querySelector('.pair-section').classList.add('active');

    function switchPair(pairIdx, btn) {
        document.querySelectorAll('.pair-section').forEach(s => s.classList.remove('active'));
        document.querySelectorAll('.pair-tab').forEach(b => b.classList.remove('active'));
        const section = document.getElementById('pair' + pairIdx);
        if (section) section.classList.add('active');
        if (btn) btn.classList.add('active');
    }

    function switchView(pairId, viewName, btn) {
        const section = document.getElementById(pairId);
        section.querySelectorAll('.text-panel').forEach(p => {
            p.classList.remove('active');
            p.style.display = 'none';
        });
        section.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
        const panel = section.querySelector('[data-view="' + viewName + '"]');
        if (panel) { panel.style.display = 'block'; panel.classList.add('active'); }
        if (btn) btn.classList.add('active');
    }

    function saveHtml() {
        const content = document.documentElement.outerHTML;
        const blob = new Blob(['<!DOCTYPE html>' + content], { type: 'text/html; charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = '교감결과.html';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
    <\/script>
</body>
</html>`;

        const newWin = window.open('', '_blank');
        if (newWin) {
            newWin.document.write(resultHtml);
            newWin.document.close();
        } else {
            alert('팝업이 차단되었습니다. 파일로 저장합니다.');
            const blob = new Blob([resultHtml], { type: 'text/html; charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = '교감결과.html';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    }

    function escapeHtml(str) {
        if (!str) return '';
        return str.replace(/&/g, '&amp;')
                  .replace(/</g, '&lt;')
                  .replace(/>/g, '&gt;')
                  .replace(/"/g, '&quot;')
                  .replace(/'/g, '&#039;');
    }
    </script>
</body>
</html>
